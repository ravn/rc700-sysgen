;************************************************************************
;*									*
;* AUTOLOAD-FILE FOR THE RC700 AND RC703 MICROCOMPUTER			*
;*  									*
;* REGNECENTRALEN OCTOBER 1982 JOS					*
;*									*
;* CHANGED BY STIG CHRISTENSEN D. 24-10-87                              *
;*                                                                      *
;* TO SUPPORT AUTOLOAD FROM MEMORYDISK INSTEAD OF HARDDISK              *
;*                                                                      *
;* AND TO LOAD CHARACTER GENERATOR SEM702                               *
;*                                                                      *
;************************************************************************ 
.Z80
; GLOBAL CONSTANT DEFINITIONS 
;

COLOR	EQU	0	;SELECT COLOR CRT AUTOLOAD VERSION
			;COLOR=0 MEANS SELECT NON-COLOR CRT AUTOLOAD VERSION
			;
			;
VERS    EQU     30      ;			
FMOVE	EQU	2048	;NUMBER OF BYTES IN PROM
FMOVS	EQU	MOVADR-BEGIN
ROM2	EQU	2000H	;ADDRESS OF TEST PROM 
RAMEN	EQU	019H	;ENABLE RAM PORT
SW1	EQU	014H	;MINI/MAXI SWITCH 
BIB	EQU	01CH	;BIB SOUND SWITCH


;MEMORY LAYOUT
TRK	EQU	0B000H	;ID COMAL READ TRACK COUNT

RSTAB	EQU	0B003H	;FLOPPY SAVE STATUS AREA
ERFLAG	EQU	0B00DH	;HARD DISK ERROR FLAG
SECTOR	EQU	0B00EH	;HARD DISK SECTOR READ COUNT
MEMADR	EQU	0B00FH	;MEMORY ADDRESS POINTER (DMA)
REPTIM	EQU	0B011H	;REPEAT OPERATION INDICATOR
DSPSTR	EQU	0B020H	;DISPLAY MEMORY BUFFER
STACK	EQU    	0FFFFH	;STACK AREA BOTTOM ADDRESS
;

PAGE
;*****************************************************************************
;  START OF PROM CODE. THE FIRST CODE BYTES WILL MOVE THE BOOTSTRAP CODE     *
;  IMAGE TO ADDRESS A000 AND FORWARD.                                        *
;*****************************************************************************

		ORG 0	;START IN ADDRESS 0 ABS.
BEGIN:	DI		;
	LD SP,STACK	;SET STACK AREA
	LD HL,FMOVS	;FIRST BYTE TO BE MOVEN
	LD DE,0A000H	;DESTINATION ADDRESS
	LD BC,FMOVE-FMOVS; NUMBER OF BYTES TO MOVE
	LDIR		;MOVE!
	JP AUTOL	;GO TO AUTOLOAD SECTION 
MOVADR:
PAGE
.PHASE 0A000H
;*****************************************************************************
;*                                                                           *
;*    AUTO LOAD SECTION:					             *    
;*									     *
;*****************************************************************************
PRAM:			;ADRESS OF THE FIRST CODEBYTE AFTER MOVING 
;  INTERRUPT TABLE:
ITRTAB:	DW DUMINT	;     DUMMY
	DW KBINT 	;PIO: KEYBOARD	"NOTE MUST NOT BE CHANGED DUE
			;                TO ID-COMAL" 
	DW DUMINT	;     DUMMY
	DW DUMINT	;     DUMMY
	DW DUMINT	;CTC2:WD1000
	DW DUMINT	;     DUMMY
	DW DUMINT	;     DUMMY
	DW DUMINT	;     DUMMY
	DW DUMINT	;CTC: DUMMY
	DW DUMINT	;     DUMMY
	DW DISINT	;     DISPLAY
	DW FLPINT	;     FLOPPY
PAGE      		      
AUTOL:	LD A,HIGH(ITRTAB) 
	LD I,A		;SET INTERRUPT VECTOR REGISTER
	IM 2		;INTERRUPT MODE 2

;INITIALIZATION OF Z80 PIO
;  PORT A: USED FOR KEYBOARD
;  PORT B: NOT USED DURING BOOTSTRAP
;
KEYCON	EQU	12H	;CONTROL PORT A
KEYDAT	EQU	10H	;DATA PORT A
MODIN	EQU	4FH	;PIO MODE =INPUT
KINT	EQU	02H	;PIO INTERRUPT VECTOR
PENINT 	EQU	87H	;PIO ENABLE INTERRUPT 
PDIINT	EQU	07H	;PIO DISABLE INTERRUPT 
;
;
;
	LD A,KINT	;SET KEYBOARD INT VEC.
	OUT (KEYCON),A	; 
	LD A,MODIN	;
	OUT (KEYCON),A	;SET INPUT MODE
	LD A,PENINT	;
	OUT (KEYCON),A  ;ENABLE KEYBOARD INTERRUPTS
	IN A,(KEYDAT)	;READ PIA DATA PORT
PAGE
;INITIALIZATION OF THE AM9517 DMA CONTROLLER
;  CHANNEL0: MEMORY DISK
;  CHANNEL1: FLOPPY DISK CONTROLLER
;  CHANNEL2: DISPLAY CONTROLLER
;  CHANNEL3: NOT USED DURING BOOTSTRAP
;
CH0ADR	EQU	0F0H	;ADDRESS REGISTER CHANNEL0
WCREG0	EQU	0F1H	;WORD COUNT REGISTER CHANNEL0
CH1ADR	EQU	0F2H	;ADDR REG CH1 
WCREG1	EQU	0F3H	;WORD COUNT REG CH1
CH2ADR	EQU	0F4H	;ADDR REG CH2
WCREG2	EQU	0F5H	;WORD COUNT REG CH2
DMACOM	EQU	0F8H	;DMA CONTROLLER COMMAND REGISTER 
DMAREQ  EQU     0F9H    ;DMAREQ REGISTER
DMAMOD	EQU	0FBH	;DMA CONTROLLER MODE REGISTER 
COMV	EQU	010H	;COMMAND VALUE 
MODE0	EQU	044H	;TRANSFER DISK TO MEMORY CH0
MODE1	EQU	045H	;TRANSFER DISK TO MEMORY CH1
MODE2	EQU	05AH	;TRANSFER MEMORY TO DISPLAY CH2(AUTOINITIALIZE)
MODE3   EQU     04BH    ;TRANSFER MEMORY TO DISPLAY (NOT USED)
CLBP	EQU	0FCH	;CLEAR BYTE COUNTER REGISTER
DMAMSK	EQU	00FH	;SET ALL DMA CHANNELS MASKBITS
CLR0	EQU	000H	;CLEAR CH0 MASK BIT 
CLR1	EQU	001H	;CLEAR CH1 MASK BIT 
CLR2	EQU	002H	;CLEAR CH2 MASK BIT
FULMSK	EQU	0FFH	;FULL MASK REGISTER
SMSK	EQU	0FAH	;SINGLE MASK REGISTER
SET0	EQU	004H	;SET CH0 MASK BIT
SET1	EQU	005H	;SET CH1 MASK BIT
;
	LD A,COMV	;SELECT COMMAND OPTIONS
	OUT (DMACOM),A	;
	LD A,MODE0	;RAMDISK WRITE TO MEMORY
	OUT (DMAMOD),A 	; 
	LD A,MODE1	;FLOPPY WRITE DISK TO MEMORY 
	OUT (DMAMOD),A 	; 
	LD A,MODE2	;CRT READ MEMORY TO CRT CONTROLLER(AUTO)
	OUT (DMAMOD),A 	;
        LD A,MODE3      ;NOT USED
        OUT (DMAMOD),A  ;
	LD A,DMAMSK	;SET ALL MASK BITS
	OUT (FULMSK),A	;
PAGE
;CTC INITIALIZATION
;  CHANNEL0: NOT USED DURING BOOTSTRAP
;  CHANNEL1: NOT USED DURING BOOTSTRAP
;  CHANNEL2: INTERRUPT INPUT FOR DISPALY  
;  CHANNEL3: INTERRUPT INPUT FOR FLOPPY CONTROLLER
;
CTCCH0	EQU	0CH	;CHANNEL0 ADDRESS
CTCCH1	EQU	0DH	;CH1 
CTCCH2	EQU	0EH	;CH2
CTCCH3	EQU	0FH	;CH3
CTCINT	EQU	10H	;INTERRUPT VECTOR FOR CTC
			;  DISPLAY INTERRUPT TABLE ENTRY =14H
 			;  FLOPPY INTERRUPT TABLE ENTRY = 16H
CTCMOD	EQU     0D7H	;MODE= INTERUPT AFTER ONE COUNT
CTCCNT	EQU	001H	;CTC COUNT = 1 
CTCRES	EQU	003H	;RESET CHANNEL COMMAND
; 
;
	LD A,CTCINT	;SET CTC INTERRUPT VECTOR
	OUT (CTCCH0),A	;
	LD A,CTCRES	;
	OUT (CTCCH0),A	;RESET CHANNEL0
	OUT (CTCCH1),A	;RESET CHANNEL1 
	LD A,CTCMOD	;SET CHANNEL2 MODE 
	OUT (CTCCH2),A	;
	LD A,CTCCNT	;SET CHANNEL2 COUNT
	OUT (CTCCH2),A	; 
	LD A,CTCMOD	;SET CHANNEL3 MODE  
	OUT (CTCCH3),A	;
	LD A,CTCCNT	;SET CHANNEL3 COUNT
	OUT (CTCCH3),A	;
PAGE
;INITIALIZATION OF THE DISPLAY BUFFER
;
	LD HL,DSPSTR	;INITIALIZE BUFFER TO ' ' CHARACTERS
	LD DE,DSPSTR+1	;
	LD BC,07CFH	;
	LD (HL),' '     ;
	LDIR		;
	LD HL,RCCOL	;MOVE COLOUR AND THE ' RC700' PROMT TO            	   	     	
	LD DE,DSPSTR    ;THE MEMORY DISPLAYBUFFER
	CALL MESSWR	;
PAGE
;INITIALIZATION OF THE INTEL 8275 DISPLAY CONTROLLER
;
;
CRTCOM	EQU	01	;CRT CONTROL REGISTER
CRTDAT	EQU	00	;CRT DATA REGISTER
LCURS	EQU	80H	;LOAD CURSOR COMMAND
CRTEN	EQU    0A0H	;CRT ENABLE INTERRUPT
PRECC	EQU    0E0H	;PRESET COUNTERS COMMAND
STDISP	EQU    023H	;START DISPLAY
CRTRES	EQU	00H	;RESET CRT CONTROLLER
PARAM1	EQU    04FH	;NORMAL ROWS,80CHAR/ROW
PARAM2	EQU    098H	;25 ROWS PER FRAME
PARAM3	EQU	7AH	;UNDERLINE IN POS 8-10 POS PER CHARACTER
PARAM4	EQU	4DH	;CURSOR FORMAT BLOCK, BLINK AND REVERSE VIDEO
;
;
	LD A,CRTRES	;RESET CRT CONTROLLER   
	OUT (CRTCOM),A	;
	LD A,PARAM1	;SET CHAR/ROW
	OUT (CRTDAT),A	;
  	LD A,PARAM2	;SET ROWS/FRAME
	OUT (CRTDAT),A	;
	LD A,PARAM3	;
	OUT (CRTDAT),A	;SET LINES PER CHAR
	LD A,PARAM4	;SET CURSER FORMAT
	OUT (CRTDAT),A	;
	LD A,LCURS	;LOAD CURSOR POSITION
	OUT (CRTCOM),A	;
	LD A,26		;A:=26 ;REMOVE CURSOR
	OUT (CRTDAT),A	;CURSOR X POS:=26
	OUT (CRTDAT),A	;CURSOR Y POS:=26
	LD A,PRECC	;PRESET COUNTERS
	OUT (CRTCOM),A	;
	LD HL,DSPSTR	;
	LD A,L		;SET LOW ADDRESS IN DMA CHANNEL2
	OUT (CH2ADR),A	;
	LD A,H		;SET HIGH ADDRESS IN DMA CHANNEL2
	OUT (CH2ADR),A	;
	OUT (CLBP),A	;CLEAR BYTE COUNTER
	LD A,0CFH	;SET WORD COUNT LOW
	OUT (WCREG2),A	;
	LD A,07H	;SET WORD COUNT HIGH 
	OUT (WCREG2),A	;
	LD A,CLR2	;CLEAR DMA CHANNEL2 MASK BIT
	OUT (SMSK),A	;
	LD A,STDISP	;START DISPLAY AND PROMT ' RC700'
	OUT (CRTCOM),A	;
PAGE
	XOR A		;
	LD (FLBFLG),A	;FLOPPY BOOT FLAG:=0
	CALL DUMINT     ;CLEAR DAISY CHAIN
                	; AND ENABLE INTERRUPTS TO RECOGNIZE KEYBOARD 
			;INTERVENTION
        LD A,055        ;WAIT FOR TIMER=0
        LD (TIMER),A    ;
        CALL LDGEN      ;
WL1:    LD A,(TIMER)     ;
        OR A            ;
        JR NZ,WL1       ;
PAGE   
;**************************************************************************** *                                                                 
;*  MEMORY DISK AUTOLOAD SECTION                                              *
;******************************************************************************
;
BIOSL   EQU     8192    ;LENGHT OF BIOSTRACK

;       MEMORYDISK PORT ASSIGNMENT
MDTRK   EQU     0EEH    ;TRACKREGISTER
MDSEC   EQU     0EFH    ;SECTOR REGISTER
MDST    EQU     0EEH    ;STATUS REGISTER

MEMDSK: IN A,(DMACOM)   ;REMOVE PENDING READY
        XOR A           ;
        OUT (DMAREQ),A  ;NO DMAREQ
        LD (HSTTRK),A   ;SET TRACK=0
        LD (HSTSEC),A   ;SET SECTOR=0
        LD BC,10        ;
        LD (SIZE),BC    ;SET SIZE=10
        CALL MDRD       ;
        LD C,B          ;BC=0
WLOOP:  DJNZ WLOOP      ;WAIT FOR DMA TO FINIS
        IN A,(DMACOM)   ;
        AND 01          ;CHECK DMA FINISED?
        JR NZ,MDDISK    ;YES CONTINUE
        LD A,4          ;
        OUT (DMAREQ),A  ;FORCE DMAREQUEST
WLOOP1: IN A,(DMACOM)    ;
        AND 01      	;
        JR NZ,WLOOP1    ;WAIT FOR DMA TO TERMINATE
        JP FLOPPY       ;THEN AUTOLOAD FROM FLOPPY

PAGE
MDDISK: LD A,(FLBFLG)   ;
        OR A            ;
        JP NZ,FLOPPY    ;IF FORCE FLOPPY_BOOT
        IN A,(MDST)     ;
        AND 01          ;IF PARITY ERROR
        CALL NZ,MDFORM  ;THEN FORMATDISK
        LD HL,0         ;
        LD (BUFFER),HL  ;LOAD BUFFER=0
        LD A,(FLBFLG)   ;
        OR A            ;
        JP NZ,FLOPPY    ;IF FORCE FLOPPY_BOOT
        OUT (RAMEN),A   ;MEMORYDISK RECOGNIZED ENABLE RAM
        LD A,0          ;
        LD (HSTTRK),A   ;
        LD BC,BIOSL-1   ;
        LD (SIZE),BC    ;
        LD A,128        ;
        LD (HSTSEC),A   ;BOOT FROM TRACK 0 SECTOR 128
        CALL MDRD      	;
        CALL MDWAIT     ;
        JP NZ,FLOPPY    ;IF PARITY ERROR THEN BOOT FROM FLOPPY
        CALL FDSTAR     ;START FLOPPY
        CALL INDISK     ;WAIT FLOPPY IN A TO BE READY
        LD HL,(0)       ; GET START ADDRESS OF BOOT FILE
        JP (HL)         ;AND EXECUTE
PAGE
;***********************************************************************
;*      MEMORYDISK FORMAT SECTION                                      *
;***********************************************************************

MDFORM: IN A,(MDST)     ;GET STATUS
        AND 0FCH        ;FIND NUMBER OF TRACK'S
        RET Z           ;RETURN IF NO TRACK
        LD HL,3000H     ;BUFFER TO PLACE E5 IN
        LD DE,3001H     ;
        LD (BUFFER),HL  ;
        LD BC,1024*16-1 ;16 SECTORS OF 1024 BYTES
        LD (SIZE),BC    ;
        INC BC         	;
        LD (HL),0E5H    ;
        LDIR            ;FILL BUFFER WITH 0E5
LOOP:   CALL MDWR       ;WRITE TRACK
        CALL WRNUM      ;WRITE NUMBER TO SCREEN
        CALL MDWAIT     ;
        LD HL,HSTTRK    ;
        INC (HL)        ;
        IN A,(MDST)      ;
        AND 0FCH        ;FIND TRACKNUMBER
        CP (HL)         ;CHECK FOR FINIS
        JR NZ,LOOP      ;
        LD DE,DSPSTR+80 ;
        LD HL,MESS3     ;
        CALL MESSWR     ;CLEAR LINE ON SCREEN
        LD BC,2047      ;MOVE PROMDIR
        XOR A           ;TO CPMDIR
        LD (SIZE),BC    ;
        LD (HSTSEC),A   ;
        LD A,64         ;SET SECTOR=0 AND TRACK=64
        LD (HSTTRK),A   ;
        CALL MDRD       ;READ 2048 BYTES
        CALL MDWAIT     ;WAIT READY
        RET NZ          ;RETURN ON ERROR
        LD A,(3000H)    ;GET FIRST BYTE OF PROMDISK
        CP 20H          ;IF NOT 20 THEN NO PROMDISK
        RET NZ          ;
        XOR A           ;
        LD (HSTTRK),A   ;
        LD (HSTSEC),A   ;SECTOR=0, TRACK=0
        CALL MDWR       ;
        JP MDWAIT       ;RETURN WHEN WRITE IS FINISED
 
PAGE
;******************************************************************
;*      MEMORY DISK READ/WRITE                                    *
;*                                                                *
;*      USE DMA CONTROLLER                                        *
;******************************************************************

MDWR:   LD B,48H        ;DMA WRITE COMMAND
        JR MDCOM        ;
MDRD:   LD B,44H        ;DMA READ COMMAND
MDCOM:  DI              ;
        LD A,04         ;SET MASKBIT
        OUT (SMSK),A    ;
        LD A,B          ;
        LD HL,(BUFFER)  ;HL=DMAADDRESS
        LD BC,(SIZE)    ;BC=BYTECOUNT
MDCOM1: OUT (DMAMOD),A  ;SET DMA MODE
        OUT (CLBP),A    ;CLEAR BYTEPOINTER
        LD A,L          ;
        OUT (CH0ADR),A  ;SET ADDRESS
        LD A,H          ;
        OUT (CH0ADR),A  ;
        LD A,C          ;
        OUT (WCREG0),A  ;
        LD A,B          ;SET BYTE COUNT
        OUT (WCREG0),A  ;
        XOR A           ;
        OUT (SMSK),A    ;
        EI              ;DMA SETUP FINISED
        LD A,(HSTTRK)   ;
        OUT (MDTRK),A   ;SET TRACK AND CLEAR ERROR IF ANY
        LD A,(HSTSEC)   ;
        OUT (MDSEC),A   ;SET SECTOR AND START DMA
        RET             ;RETURN
MDWAIT: IN A,(MDST)     ;REPEAT
        AND 02H         ;CHECK BUSY
        JR NZ,MDWAIT    ;UNTIL NOT BUSY
        IN A,(MDST)     ;
        AND 01H         ;CHECK PARITY BIT
        LD (ERFLAG),A   ;
        RET             ;ERROR IF A<>0
PAGE
;*********************************************************************
;*                                                                   *
;*      LOAD CHARACTERGENERATOR SEM 702                              *
;*                                                                   *
;*********************************************************************

CHARLN  EQU     0D1H    ;CHARACTER
DOTLN   EQU     0D2H    ;DOT LINE
CHARDA  EQU     0D3H    ;RAM DATA
LDGEN:  LD BC,0         ;C=LINE COUNT
        LD IX,2000H     ;B=CHAR COUNT
        XOR A           ;IX=POINTER
        OUT (CHARLN),A  ;
        OUT (DOTLN),A   ;
LDLP:   LD E,(IX)       ;GET CHAR
        LD D,8          ;
LDLP1:  RL E            ;SHIFT BIT TO CARRY
        RR A            ;SHIFT CARRY TO BIT
        DEC D           ;
        JR NZ,LDLP1     ;
        OUT (CHARDA),A  ;PUT IT OUT
        INC IX          ;POINT TO NEXT CHAR
        LD A,C          ;
        INC A           ;GET NEXT DOT LINE
        AND 0FH         ;
        LD C,A          ;
        OUT (DOTLN),A   ;SET NEXT DOT LINE
        JR NZ,LDLP      ;LOOP
        INC B           ;GET NEXT CHAR
        LD A,B          ;
        CP 128          ;FINIS
        RET Z           ;YES RETURN
        OUT (CHARLN),A  ; SET NEXT CHAR
        JR LDLP         ;
PAGE
;*****************************************************************************
;*               							     *
;* FLOPPY_BOOT SECTION							     *
;*									     *
;*****************************************************************************
;
FLOPPY:	CALL INITFL	;FLOPPY_BOOT INITIALIZE FDC AND RECALIBRATE DRIVE0
	OUT (RAMEN),A	; FLOPPY RECOGNIZED ENABLE RAM IN PROM1 ADDRESS AREA
	LD HL,00	; MEMORY_ADR:=0
	LD (MEMADR),HL	;
	CALL READ	; READ_TRACK0 
PAGE
;
;CHECK FOR ID-COMAL OR (CP/M - COMAL80) BOOT
;
	LD BC,6		;
	LD HL,IDTXT  	; HL POINTS TO ' RC700' TEXT
	LD DE,1		; DE POINTS TO THE IMAGE LOADED FROM DISK
	CALL COMSTR	; COMPARE STRINGS
	JP Z,IDBOOT	; IF MEMORY IMAGE TEXT=' RC700' THEN
			; GO TO ID-COMAL BOOT
 	LD BC,5		;
	LD HL,CPMTXT 	; HL POINTS TO ' RC700' TEXT
	LD DE,7		; DE POINTS TO THE IMAGE LOADED FROM DISK
	CALL COMSTR	; COMPARE STRINGS
	JR Z,CPCOMB	;IF THE FIRST FIVE CHAR OF MEMORY IMAGE IS DIFFERENT
			;FROM ' RC70' THEN GO TO ERROR
			;ELSE GO TO CP/M-COMAL80 BOOT
ERXIT:	LD HL,ERMES3	; IF ERROR THEN WRITE('* NO SYSTEM FILES *')
	JP ERR		;
PAGE
; 
;COMAL80 - CP/M AUTOLOAD
;
CPCOMB: LD IX,COMBUF	;INITIALIZE READ COMMAND BUFFER
	LD (IX),DUALC	;DUAL DENSITY READ COMMAND
	LD (IX+1),DR0H1	;DRIVE 0 HEAD 1
	LD (IX+5),BDSEC	;256 BYTES PER SECTOR
	LD (IX+7),DUAGPL;GAB 3 DUAL DENSITY
	LD (IX+8),DUADTL; DTL DUMMY=FFH
	                ;
	LD A,5		;
	LD (REPTIM),A	;
REPRD2:	XOR A		;REPEAT
	LD (FL_FLG),A	;CLEAR FLOPPY INT FLAG
	IN A,(SW1)	;
	AND 80H
	JR Z,IMBUF	;  IF MINI_DRIVE THEN
	LD DE,MIBYT1	;  BYTES TO TRANSFER:= 256*16
	JR INID		;
IMBUF:	LD DE,MXBYT1	;  ELSE BYTES TO TRANSFER:= 256*26
INID:	LD C,CH1ADR	;  INITIALIZE AND ENABLE DMA
	LD A,SET1	;
	LD HL,(TRBYT)	;
	INC HL		;TO GET THE FIRST FREE ADDRESS
	CALL STPDMA	;
	CALL FLRTRK	;  READ CYLLINDER 0 SIDE 1
	CALL READOK	;  WAIT- CHECK READING OK 
	JR C,REPRD2	;UNTIL REPTIM=0 OR NOT ERROR
			;
	LD HL,(00)	;LOAD BOOTADDRESS
	JP (HL)		;AND TRANSFER CONTROL
PAGE
;*****************************************************************************
;* 									     *
;* ID COMAL AUTOLOAD SECTION:					             *
;*  MINI DRIVES: THE SYSTEM CODE IS ON TRACK 1-3		             *
;*               SIDE0= 16 SECTORS
;*               SIDE1= 10 SECTORS(LAST 6 SECTORS GARBAGE)
;*               ALWAYS DOBBELT SIDED AND SINGLE DENSITY
;*
;*  MAXI DRIVES: THE SYSTEM CODE IS ON TRACK 1-3
;*                ALLWAYS SINGLE SIDED AND SINGLE DENSITY
;* 							                     *    		 	 
;*****************************************************************************

MTRK	EQU	86H	;MINI DRIVES MULTITRACK FDC COMMAND
MINS1	EQU	1280	;BYTES ON SIDE 1 MINI DRIVES ID-COMAL
SBID	EQU	3328	;SIGNIFICANTE BYTES ON ONE CYLINDER          
IDBADR	EQU	1000H	;ID COMAL BOOT ADDRESS

;
IDBOOT:			;
	IN A,(SW1)	;IF MINI_DRIVES THEN
	AND 80H		;
	JR Z,CATCH	;
	LD A,DR0H1	; READ CATALOG FROM TRACK0 SIDE1
	LD (COMBUF+1),A	;
	LD HL,MIBYT0+1	;
	LD (MEMADR),HL	;
	CALL READ	;
PAGE
;ID COMAL CATALOG CHECK
IDCAT	EQU	0B60H	;ID COMAL CATALOG START ADDRESS-20H
FILDI	EQU	020H	;ENTRY DISPLACEMENT
FILTY	EQU	013H	;SYSTEM-FILE TYPE VALUE
OUTCAT	EQU	00EH    ;MOST SIGNIFICANT ADDRESS BYTE OF THE FIRST
			;PAGE THAT LIES OUT OF THE CATALOG ADDRESS SPACE 
;THE CATALOG CONTAINS 12 ENTRIES EACH 32 BYTES LONG
;THE LAST ENTRY ADDRESS IS 0DE0H
;
CATCH:	LD HL,IDCAT	;ENTRY NUMBER:= 0
REPENT:	LD DE,FILDI	;WHILE ENTRY.EMPTY AND ENTRY NUMBER<13 DO
	ADD HL,DE	;
	LD A,OUTCAT	;
	CP H		;
	JP Z,DIRERR	; ENTRY NUMBER:= ENTRY NUMBER+1;
	LD A,(HL)	;
	OR A		;
	JR Z,REPENT	;
			;IF ENTRY NUMBER>12 THENGO TO DIR_ERROR
	PUSH HL		;
	INC HL		;
	LD DE,SYSM-1	;IF ENTRY.TEXT<>'SYSM' THEN GO TO DIR_ERROR
	LD BC,4		;
	CALL COMSTR	;
	JP NZ,DIRERR	;
	POP HL		;
	PUSH HL		;
	LD DE,FILDI	;ENTRY NUMBER:= ENTRY NUMBER+1
	ADD HL,DE	;
	PUSH HL		;
	INC HL		;
	LD DE,SYSC-1	;IF ENTRY.TEXT<>'SYSC' THEN GO TO DIR_ERROR
	LD BC,4		;
	CALL COMSTR	;
	JP NZ,DIRERR	;
	LD B,2		;FOR I:=ENTRY NUMBER DOWNTO ENTRY NUMBER-1 DO
	LD DE,8		;
REPATR:	POP HL		; IF ENTRY(I).ATTRIBUTE<>SYSTEMFILE THEN
	ADD HL,DE	; GO TO DIR_ERRROR
	LD A,(HL)	;
	AND 3FH		;
	CP FILTY	;
	JP NZ,DIRERR	;
	DJNZ REPATR	;
PAGE
;LOAD ID COMAL SYSTEM CODE		 		
	LD HL,00	;
	LD (MEMADR),HL	; MEMORY_ADDRESS:=0
	LD A,1		;
	LD (TRK),A	; TRACK:=1
	IN A,(SW1)	;
	AND 80H		;
	JP Z,MAXIRD	;  IF MINI=DRIVES THEN
	LD A,(TRK)	;BEGIN
IDRL1:	LD B,A		;  FOR I:=1 TO 9 DO
	CALL FLO7	;  BEGIN
	LD A,(TRK)	;
	LD (CURID),A	;
	XOR A		;    
	LD (COMBUF+1),A	;    SET DRIVE 0 HEAD 0
 	CALL READ	;    SEEKTRACK(TRACK)
	LD HL,(MEMADR)	;    READTRACK(SIDE0)
	LD DE,MIBYT0+1	;    MEMORY_ADR:=MEMORY_ADR+16*128
 	ADD HL,DE	;
	LD (MEMADR),HL	;
	LD A,DR0H1	;
	LD (COMBUF+1),A	;    SET DRIVE 0 HEAD 1
	CALL READ	;    READTRACK(SIDE1)
	LD HL,(MEMADR)	;
	LD DE,MINS1	;
	ADD HL,DE	;    MEMORY=ADR:=MEMORY_ADR+10*128
	LD (MEMADR),HL	;
	LD A,(TRK)	;
	INC A		;
	LD (TRK),A	;
	CP 10		;
	JR NZ,IDRL1	;  END
	JR IDFIN	;     
MAXIRD:	LD A,(TRK)	;ELSE
IDRL2:	LD B,A		;FOR I:=1 TO 9 DO 
	CALL FLO7	;BEGIN
	LD A,(TRK)	;  SEEKTRACK(TRACK)
	LD (CURID),A	;  CURRENT CYL NUMBER:=TRACK
	CALL READ	;  READTRACK(TRACK)
	LD HL,(MEMADR)	;
	LD DE,SBID	;MEMORY_ADDRESS:=MEMORY_ADDRESS+(26*128)
	ADD HL,DE	;
	LD (MEMADR),HL	;
	LD A,(TRK)	;
	INC A		;
	LD (TRK),A	;
	CP 10		;
	JR NZ,IDRL2	;END(*FOR LOOP*)
			;
IDFIN:	LD A,COMV	;
	OUT (DMACOM),A	;
	LD A,MODE0	; INITIALIZE DMA FOR ID-COMAL USE
	OUT (DMAMOD),A 	;
	LD A,MODE1	;
	OUT (DMAMOD),A 	;
	LD A,4AH	;
	OUT (DMAMOD),A 	;
	LD A,4BH	;
	OUT (DMAMOD),A 	;
	LD A,DMAMSK	;
	OUT (FULMSK),A	;
	LD A,PENINT	; ENABLE KEYBORD INTERRUPTS IF DISABLED BY
	OUT (KEYCON),A	; THE KEYBOARD INTERRUPT SERVICE RUTINE
			;		
	LD HL,IDBADR	; LOAD ID COMAL BOOT ADDRESS
	JP (HL)		; AND TRANSFER CONTROL
PAGE
DIRERR:	LD HL,ERMES3	;PROCEDURE ID-COMAL DIRECTORY_ERROR
	JP ERR		;
;
;
;
COMSTR:	INC DE		;PROCEDURE COMPARE_STRINGS
	LD A,(DE)	;
	CPI		;
	RET NZ		;
	JP PE,COMSTR	;
	RET		;
  
PAGE
;************************************************************************
;*									*
;*   FLOPPY ROUTINES:							*
;*									*
;************************************************************************
;
FDC	EQU	04H	;FLOPPY COMMAND REGISTER
FDD	EQU	05H	;FLOPPY DATA REGISTER

;
;
;
READ:			;PROCEDURE READTRACK
	LD A,5		;BEGIN
	LD (REPTIM),A	;  REPEAT
RDL11:	XOR A		;    CLEAR FLOPPY_INT FLAG
	LD (FL_FLG),A	;
	LD C,CH1ADR	;
	LD A,SET1	;
	LD HL,(MEMADR)	;
	LD DE,(TRBYT)	;
	CALL STPDMA	;    INITIALIZE AND ENABLE DMA
	CALL FLRTRK	;    READ_TRACK 
	CALL READOK	;
	JR C,RDL11	;  UNTIL RETIM=0 OR NOT ERROR;
	RET		;END
PAGE
;
INITFL:	IN A,(SW1)	;PROCEDURE INITIALIZE FLOPPY
	AND 80H		;BEGIN
	JR Z,IFDC0	;  IF MINI_DRIVES THEN
	LD A,0FH	;  BEGIN
	LD (FDCINI+2),A	;    SET SRT:=16MS AND HUT:=240MS
	LD HL,MIBYT0	;    TRANSFER_BYTES:=16*128
	LD (TRBYT),HL	;
IFDC0:	CALL FDSTAR	;  END
      	IN A,(FDC)	;  WHILE FDC BUSY DO WAIT
	AND 01FH	;
	JR NZ,IFDC0	;
	LD HL,FDCINI	;  FOR I:=(B) DOWNTO 1 DO
	LD B,(HL)	;  BEGIN
IFDC1:	INC HL		;
	CALL FLO2	;    WAIT_READY_WRITE
	LD A,(HL)	;
	OUT (FDD),A	;    WRITE FDC INIT COMMAND
	DJNZ IFDC1	;  END
        CALL INDISK     ; WAIT FOR DISK IN DRIVE
	LD A,5		;
	LD (REPTIM),A	;
RECREP: XOR A		;  REPEAT
	LD (FL_FLG),A	;    CLEAR FLOPPY INT FLAG
        DEC A           ;SET TIMER=5 SEC
        LD (TIMER),A    ;
	CALL FLO4	;    RECALIBRATE DRIVE0
			;    WHILE FDC NOT READY OR NOT TIMEOUT DO
FW1:	LD A,(FL_FLG)	;    BEGIN
	OR A		;      CHECK FLOPPY INT FLAG FOR FDC READY
	JR NZ,FD_RDY	;
        LD A,(TIMER)    ;IF TIMER=0 THEN TIMEOUT
        OR A            ;
	JR NZ,FW1	;     END
	LD HL,ERMES1	;     IF TIMEOUT THEN WRITE(PLEASE INSERT DISKETTE)
	JP ERR		;     ERROR_ABORT
FD_RDY:	LD A,(RSTAB)	;     IF RECALIBRATE_ERROR THEN TIMES:=TIMES-1
	AND 0D0H	;
	RET Z		;
	LD A,(REPTIM)   ;
	DEC A		;
	LD (REPTIM),A	;
	JR NZ,RECREP	;  UNTIL TIMES=0 OR NOT ERROR
	LD HL,ERMES1	;  IF RECALIBRATEERROR THEN
	JP ERR		;  WRITE(PLEASE INSERT DISKETTE)
			;  ERROR_ABORT  	
			;END(*PROCEDURE INITIALIZE FLOPPY*)
INDISK: LD DE,DSPSTR+1920;
        PUSH DE         ;WRITE 'INSERT DISKETTE'
        LD HL,MESS4     ;IN BOTTOM OF SCREEN
        CALL MESSWR     ;
        CALL FLO8       ;WAIT FOR DISK TO BE READY
        POP DE          ;
        LD HL,MESS3     ;CLEAR TEXT AT BOTTOM
        JP MESSWR       ;
PAGE
;
FLO2:	IN A,(FDC)	;PROCEDURE WAIT_READY_WRITE
	AND 0C0H	;
	CP 080H		;
	JR NZ,FLO2	;
	RET		;
;
;
;
FLO3:	IN A,(FDC)	;PROCEDURE WAIT_READY_READ
	AND 0C0H	;
	CP 0C0H		;
	JR NZ,FLO3	;
	RET		;
;
;
;
FLO4:			;PROCEDURE RECALIBRATE_DRIVE0
			;BEGIN
	CALL FLO2	;  WAIT_READY_WRITE
	LD A,7		;
	OUT (FDD),A	;  RECALIBRATE COMMAND
	CALL FLO2	;  WAIT_READY_WRITE
	LD A,00		;
	OUT (FDD),A	;  SELECT DRIVE0
	RET		;
;
FLO8:   DI              ;
        CALL FLO2       ;WAIT_READY_WRITE
        LD A,4          ;
        OUT (FDD),A     ;SENSE DRIVES_STATUS COMMAND
        CALL FLO2       ;WAIT_READY_WRITE
        XOR A           ;
        OUT (FDD),A     ;
        CALL FLO3       ;WAIT_READY_READ
        IN A,(FDD)       ;
        EI              ;
        AND 23H         ;CHECK DRIVE (READY)
        JR Z,FLO8       ;NO WAIT
        RET             ;
PAGE
FLO6:			;PROCEDURE SENSE_INTERRUPT_STATUS
			;BEGIN
	CALL FLO2	;  WAIT_READY_WRITE
	LD A,8		;
	OUT (FDD),A	;  SENSE INTERRUPT COMMAND
	CALL FLO3	;  WAIT_READT_READ
	IN A,(FDD)	;
	LD (RSTAB),A	;  RSTAB:=STATUS_REGISTER_0
	AND 0C0H	;
	CP 80H		;
	RET Z		;
	CALL FLO3	;  WAIT_READY_READ
	IN A,(FDD)	;  
	LD (RSTAB+1),A	;  RSTAB1:=STATUS_REGISTER_1
	RET		;END
;
;
;
FLO7:			;PROCEDURE SEEK_TRACK
			;"NEW CYLINDER NUMBER IN B REGISTER"
	XOR A		;BEGIN
	LD (FL_FLG),A	;  "CLEAR FLOPPY INT FLAG"
	CALL FLO2	;  WAIT_READY_WRITE 
	LD A,0FH	;
	OUT (FDD),A	;  SEEK TRACK COMMAND
	CALL FLO2	;  WAIT READY WRITE
	XOR A		;
	OUT (FDD),A	;  SET DRIVE0/HEAD0
	CALL FLO2	;  WAIT READY WRITE
	LD A,B		;
	OUT (FDD),A	;  SET NEW CYLINDER NUMBER
SREP1:	LD A,(FL_FLG)	;
	OR A		;
	JR Z,SREP1	;  WHILE FDC BUSY DO;
	LD A,(RSTAB)    ;
	AND 0F0H	;  IF SEEK_ERROR THEN
	CP 20H		;
	RET Z		;  WRITE("*DISKETTE ERROR*)
	LD HL,ERMES0	;
	JP ERR		;

			
PAGE
RSULT:			;PROCEDURE READ_RESULT
			;BEGIN
	LD HL,RSTAB	;
	LD D,3		;
RSL1:	CALL RSTAT	;  FOR I:=1 TO 3 DO RESULT_TABLE(I):=FDC_STATUS(I-1)
	RET Z		;
	DEC D		;
	JR NZ,RSL1	;
	LD D,4		;
	LD HL,CURID	;
RSL2:	CALL RSTAT	;  FOR I:=1 TO 4 DO CURID(I):=FDC_ID(I)
	RET Z		;
	DEC D		;
	JR NZ,RSL2	;
	RET		;END
;
;
RSTAT:			;PROCEDURE READ_FLOPPY_RESULT
	CALL FLO3	;
	IN A,(FDD)	;
	LD (HL),A	;
	INC HL		;
	LD A,4		;
RLOOP1:	DEC A		;
	JR NZ,RLOOP1	;CRITICAL FDC TIMING
	IN A,(FDC)	;
	AND 10H		;
	RET		;
PAGE
	
FDSTAR:	LD A,1		;PROCEDURE START_MINI_MOTOR
	OUT (SW1),A	;
	LD BC,600H	;
W1:	LD A,0FFH	; WAIT(1 SEC)
W2:	DEC A		;
	JR NZ,W2	;
	DEC BC		;
	LD A,C		;
	OR B		;
	JR NZ,W1	;
	RET		;
;
;
;       PROCEDURE STOP_MINI_MOTOR
FDSTOP:	LD A,0          ;
	OUT (SW1),A	; STOP_MOTOR
	RET		;
PAGE
FLRTRK:	DI		;
	LD HL,COMBUF	;PROCEDURE FLOPPY_READTRACK	
	LD B,9		;FOR I:1 TO 9 DO
REPCOM:	CALL FLO2	;BEGIN
	LD A,(HL)	;  WAIT_READY_WRITE
	OUT (FDD),A	;  WRITE.CONTROLLER(COMBUF(I))
	INC HL		;
	DEC B		;
	JR NZ,REPCOM	;
	EI		;
	RET		;END
;
;
;
READOK:	             	;PROCEDURE CHECK_READING_OK     
        LD A,0FFH       ;
        LD (TIMER),A    ;SET TIMER=5 SEC
WFLP:	LD A,(FL_FLG)	;BEGIN				
	OR A		;
	JR NZ,RDOK?	;  WHILE FDC BUSY AND NOT TIMEOUT DO;
	LD A,(TIMER)	;
        OR A  		;
	JR NZ,WFLP	;
	JR EEXIT1	; IF TIMEOUT THEN GO TO ERROR
RDOK?:	LD A,(RSTAB)	;
	AND 0C0H	;"THE AND OPERATION WILL CLEAR CARRY FLAG"
	RET Z		;
	CP 40H		;
	JR NZ,CEXIT	;
	LD A,(RSTAB+1)	;
	AND 035H	;
	RET Z		; IF NOT READ_ERROR THEN RETURN
CEXIT:	LD A,(REPTIM)	; ELSE BEGIN
	DEC A		;        REPEAT_TIMES:=REPEAT_TIMES-1 
	LD (REPTIM),A	;
	JR Z,EEXIT	;        IF REPEAT_TIMES>0 THEN     
	SCF		;        SET_CARRY
	RET		;        ELSE
EEXIT:  LD HL,ERMES0	;        WRITE('*DISKETTE ERROR*')
	JP ERR		;
EEXIT1:	LD HL,ERMES1	;        WRITE (*PLEASE INSERT DISKETTE*)
	JP ERR		;
PAGE
;FLOPPY DISK SETUP CONSTANTS
;
;MINI DRIVES CONSTANTS
MIBYT0	EQU	2047	;BYTES TRACK0 SODE0(16*128)-1
MIBYT1	EQU	4095	;BYTES TRACK0 SIDE1(16*256)-1
;
;MAXI DRIVES CONSTANTS
;
MXBYT0	EQU	3327	;BYTES TRACK0 SIDE0(26*128)-1 
MXBYT1	EQU	6655	;BYTES TRACK0 SIDE1(26*256)-1
;
;MISCELLENEOUS DISK CONSTANTS
;
DUALC	EQU	042H	;DUAL DENSITY READ COMMAND
DUADTL	EQU	0FFH	;DTL FOR DUAL DENSITY
DUAGPL	EQU	00EH	;GAB3 FOR DUAL DENSITY
DR0H1	EQU	004H	;DRIVE0 HEAD1
BDSEC	EQU	001H	;N FOR DUAL DENSITY
MINEOT	EQU	010H	;MINIDRIVES EOT=16
;
;
;READ DISK COMMAND BUFFER
COMBUF:	DB 02H		;READ TRACK COMMAND(SINGLE DENSITY)
	DB 00H		;DRIVE0/HEAD0
CURID:			;CURRENT FLOPPY ID INFO
	DB 00H		;CYLINDER NUMBER
	DB 00H		;HEAD ADDRESS
	DB 01H		;RECORD NUMBER
	DB 00H		;RECORD LENGTH
        
	DB 1AH		;EOT
	DB 07H		;GAB3
	DB 80H		;DTL
    
TRBYT:	DW MXBYT0	;NUMBER OF BYTES TO TRANSFER DURING DMA FROM ONE
			;TRACK(DEFAULT MAXI-DRIVE TRACK0 SIDE0)

FDCINI:			;FDC SPECIFY COMMAND BUFFER
	DB 3		;NUMBER OF COMMANDS
	DB 3		;SPECIFY COMMAND
	DB 0DFH		;SRT=3MS HUT=240MS
	DB 028H		;HLT=40MS DMAMODE


PAGE
STPDMA:                 ;PROCEDURE SET_UP_DMA
                        ;READING FROM DISK TO MEMORY
                        ;CHANNEL ADDRESS IN C REGISTER
                        ;DMA MEMORY ADDRESS IN HL REGISTER
                        ;NUMBER OF BYTES TO TRANSFER IN DE REGISTER
                        ;SETMASK IN A REGISTER
        DI              ;BEGIN
        OUT (SMSK),A    ;SET CHANNEL MASK
        OUT (CLBP),A    ;CLAR BYTE POINTER
        OUT (C),L       ;SET LOW ADDRESS
        OUT (C),H       ;SET HIGH ADDRESS
        INC C           ;
        OUT (C),E       ;SET LOW WORDCOUNT
        OUT (C),D       ;SET HIGH WORDCOUNT
        RES 2,A         ;CLEAR MASK BIT
        OUT (SMSK),A    ;ENABLE DMA
        EI              ;
        RET             ;END


PAGE
;*****************************************************************************         	
;*
;* INTERRUPT SERVICE RUTINES:
;*
;*****************************************************************************
;
DUMINT:	EI 		;PROCEDURE DUMMY_INTERRUPT
	RETI		;
;
;
;
KBINT:	EX AF,AF'	;PROCEDURE KEYBOARD_INTERRUPT
	IN A,(KEYDAT)	;BEGIN
	AND 05FH	;  (A):=INCHAR("MASK LOWER CASE LETTERS TO UPPER")
	CP 'F'   	;  IF FLOPPY_BOOT_CHAR THEN
	JR NZ,T22	;
	LD (FLBFLG),A	;  FLOPPY_BOOT:=TRUE
T22:	EX AF,AF'       ;
        EI              ;
        RETI            ;END
;
;
FLPINT:	EX AF,AF'	;PROCEDURE FLOPPY_INTERRUPT
	EXX		;BEGIN
	LD A,0FFH	;  FLOPPY_FLAG:=FALSE
	LD (FL_FLG),A	;
	LD A,5		;  "FDC CRITICAL TIMING"
TIMFLI:	DEC A		;
	JR NZ,TIMFLI	;
	IN A,(FDC)	;
	AND 10H		; "NON DMA MODE TEST"
	JR NZ,RRES	;
	CALL FLO6	; SENSE INTERRUPT STATUS
	JR FEXIT	;
RRES:	CALL RSULT	; READ RESULT
FEXIT:	EX AF,AF'	;
	EXX		;
	EI		;
	RETI		;END
;
;
;
DISINT:	EX AF,AF'	;PROCEDURE DISPLAY_INTERRUPT
	IN A,(CRTCOM)	;REMOVE INTERRUPT BY READING STATUS
        LD A,(TIMER)     ;IF TIMER <> 0 THEN TIMER=TIMER-1
        OR A            ;
        JR Z,DISIN1     ;
        DEC A           ;
        LD (TIMER),A  ;
DISIN1: EX AF,AF'       ;
	EI		;
	RETI		;
PAGE
ERR:			;PROCEDURE ERROR_ABORT        
	LD DE,DSPSTR+160;START WRITING IN DISPLAY BUFFER LINE 2
        CALL MESSWR     ;WRITE MASSAGE
FIN:	OUT (BIB),A	;  PROMT FOR ABORT TO CRT
	CALL FDSTOP	;  STOP_MINI_MOTOR
ALOOP:	JR ALOOP        ; ABORT


WRNUM:  LD A,(HSTTRK)    ; WRITE TRACKNUMBER 
        LD HL,MESS2+2   ; UNDER FORMATTING
        LD (HL),'0'     ;
        DEC HL          ;
        LD (HL),'0'     ;
        DEC HL          ;
        LD (HL),'0'     ;
        LD B,100        ;
        CALL COMMON     ; CHECK AND MINUS 100
        INC HL          ;
        LD B,10         ;
        CALL COMMON     ; CHECK AND MINUS 10
        INC HL          ;
        OR (HL)         ;
        LD (HL),A       ; SET 1
        LD HL,MESS1     ; WRITE 'FORMATTING .....'
        LD DE,DSPSTR+80 ; IN LINE 2
MESSWR: LD A,(HL)       ; WHILE (HL) <> 0 DO
        OR A            ;
        RET Z           ;
        LD (DE),A       ; WRITE_CHAR
        INC DE          ;
        INC HL          ;
        JR MESSWR       ;
COMMON: CP B            ; IF A>B THEN
        RET C           ;
        INC (HL)        ; INC TEXT
        SUB B           ; A=A-B
        JR COMMON       ; ENDIF
;
PAGE
;DATA AREA
BUFFER:	DW 0		;BUFFER USED WHEN FORMATTING RAMDISK
FLBFLG:	DB 0		;FORCE FLOPPY BOOT FLAG
FL_FLG:	DB 0		;FLOPPY INTERRUPT FLAG
HSTTRK:	DB 0		;TRACK COUNT FOR MEMDISK
HSTSEC: DB 0		;SECTOR COUNT FOR MEMDISK
SIZE:   DW 0            ;NUMBER OF BYTES TRANSFER
TIMER:  DB 0            ;TIMEOUT TICKS IN SYSTEM
;
;
;RUN TIME MESSAGES
ERMES0:	DB '* DISKETTE ERROR *',0
ERMES1:	DB '* PLEASE INSERT DISKETTE AND PRESS RESET *',0
ERMES2: DB '  ',0
ERMES3:	DB '* NO SYSTEM FILES *',0
MESS1:  DB 'FORMATTING TRACK: '
MESS2:  DB '000',0
MESS3:  DB '                                ',0
MESS4:  DB '* INSERT DISKETTE IN DRIVE A *',0
;
;
SYSM:	DB 'SYSM'
SYSC:	DB 'SYSC'
;
;
;
;
;CRT COLOR DECRIPTION
COL	EQU	193	;COLOR ATTRIBUTE
BACK	EQU	000	;SELECT BACKGROUND
FORG	EQU	002	;SELECT FORGROUND
BLUE	EQU	004	;BLUE CANON
RED	EQU	008	;RED CANON
GREEN	EQU	016	;GREEN CANON
;
;
IF COLOR  
RCCOL:	DB COL+BACK	;NO CANONS GIVES BLACK
	DB COL+FORG+RED+GREEN; GIVING YELLOW
ELSE
RCCOL:                  ;IF NOT COLOR THEN WRITE ('')
ENDIF
        DB 'RC702E '    ;RC MICRO PROMT TEXT
        DB 'Autoload Version '
        DB VERS/10+'0','.',VERS MOD 10 +'0'
TCMOP:	DB 0   		;
IDTXT:  DB ' RC700'
CPMTXT: DB ' RC700'
.DEPHASE
POS$:			;LIST DEVICE OFF IN MACRO EXPANSION			
.XLIST			;
			;NOTE NUMBER OFF FREE BYTES IN PROM
;
REPT FMOVE-(POS$-BEGIN)	;;
	DB 0FFH		;;FILL REST OF PROM WITH FF'S
ENDM			;;

.LIST
;
END 

    LD D,8          ;
LDLP1:  RL E            ;SHIFT BIT TO CARRY
        RR A            ;SHIFT CARRY TO B